<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Automation Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
    <style>
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #5D5CDE;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .queue-item {
            transition: all 0.3s ease;
        }
        .queue-item.running {
            background: linear-gradient(135deg, #5D5CDE, #7C4DFF);
            color: white;
        }
        .queue-item.completed {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
        }
        .queue-item.failed {
            background: linear-gradient(135deg, #EF4444, #DC2626);
            color: white;
        }
        .response-area {
            min-height: 400px;
            max-height: 600px;
            border: 2px dashed #E5E7EB;
            transition: all 0.3s ease;
        }
        .response-area.active {
            border-color: #5D5CDE;
            border-style: solid;
        }
        .modal {
            backdrop-filter: blur(4px);
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10B981;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white transition-colors">
    <div class="container mx-auto px-4 py-6 max-w-6xl">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-blue-600 mb-2">
                AI Model Automation Runner
            </h1>
            <p class="text-gray-600 dark:text-gray-400">Sequential automated model execution with checkpoint control</p>
        </header>

        <!-- Input Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <div class="lg:col-span-2">
                <label for="main-prompt" class="block text-sm font-medium mb-2">Main Prompt</label>
                <textarea id="main-prompt" rows="6" class="w-full p-4 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-base" placeholder="Enter your query here..."></textarea>
            </div>
            <div>
                <label for="system-prompt" class="block text-sm font-medium mb-2">System Instructions</label>
                <textarea id="system-prompt" rows="6" class="w-full p-4 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-base" placeholder="Optional system prompt..."></textarea>
            </div>
        </div>

        <!-- Model Selection & Queue -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- Model Selection -->
            <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                <h3 class="text-lg font-semibold mb-4">Select Models</h3>
                <div class="space-y-2 max-h-80 overflow-y-auto" id="model-selection">
                    <!-- Models will be populated by JavaScript -->
                </div>
                <div class="mt-4 flex gap-2">
                    <button id="select-all" class="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 text-sm">
                        Select All
                    </button>
                    <button id="clear-all" class="px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600 text-sm">
                        Clear All
                    </button>
                </div>
            </div>

            <!-- Execution Queue -->
            <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                <h3 class="text-lg font-semibold mb-4">Execution Queue</h3>
                <div class="space-y-2 max-h-80 overflow-y-auto" id="execution-queue">
                    <p class="text-gray-500 italic">Select models to build queue</p>
                </div>
                <div class="mt-4">
                    <div class="text-sm text-gray-600 dark:text-gray-400">
                        <span id="queue-count">0</span> models selected
                    </div>
                </div>
            </div>
        </div>

        <!-- Execution Controls -->
        <div class="bg-gradient-to-r from-purple-100 to-blue-100 dark:from-purple-900 dark:to-blue-900 p-4 rounded-lg mb-6">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                <div>
                    <div class="text-lg font-semibold">Execution Status</div>
                    <div class="text-sm text-gray-600 dark:text-gray-400">
                        <span id="progress-text">Ready to start</span>
                    </div>
                </div>
                <div class="flex gap-3">
                    <button id="start-automation" class="px-6 py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white font-semibold rounded-lg hover:from-purple-700 hover:to-pink-700 transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                        Start Automation (5-batch)
                    </button>
                    <button id="start-manual" class="px-6 py-3 bg-gradient-to-r from-blue-600 to-cyan-600 text-white font-semibold rounded-lg hover:from-blue-700 hover:to-cyan-700 transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                        Manual Mode (1-by-1)
                    </button>
                    <button id="stop-execution" class="px-6 py-3 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition-colors hidden">
                        Stop
                    </button>
                </div>
            </div>
        </div>

        <!-- Current Response Area -->
        <div class="mb-6">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-xl font-semibold">Current Response</h3>
                <div class="flex items-center gap-2" id="current-model-info">
                    <span class="text-gray-500">No model running</span>
                </div>
            </div>
            <div id="response-area" class="response-area p-6 rounded-lg bg-gray-50 dark:bg-gray-800 overflow-auto">
                <p class="text-gray-500 dark:text-gray-400 italic text-center">Select models and start execution to see responses</p>
            </div>
        </div>

        <!-- Debug Log -->
        <div class="mt-8">
            <button id="toggle-log" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm">
                Show Debug Log
            </button>
            <div id="debug-log" class="hidden mt-4 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg border max-h-60 overflow-y-auto">
                <div class="text-xs font-mono" id="log-content">Debug log will appear here...</div>
            </div>
        </div>
    </div>

    <!-- Checkpoint Modal -->
    <div id="checkpoint-modal" class="fixed inset-0 bg-black bg-opacity-50 modal hidden flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
            <h3 class="text-xl font-semibold mb-4">Checkpoint Reached</h3>
            <p class="text-gray-700 dark:text-gray-300 mb-4">
                Completed <span id="checkpoint-completed">5</span> models successfully.<br>
                Downloaded <span id="checkpoint-downloads">5</span> responses.
            </p>
            <p class="text-gray-700 dark:text-gray-300 mb-6">
                Continue with the next batch?
            </p>
            <div class="flex justify-end space-x-3">
                <button id="checkpoint-stop" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">
                    Stop Here
                </button>
                <button id="checkpoint-continue" class="px-4 py-2 bg-purple-600 text-white hover:bg-purple-700 rounded">
                    Continue
                </button>
            </div>
        </div>
    </div>

    <!-- Success Notification -->
    <div id="notification" class="notification">
        Action completed!
    </div>

    <script>
        // Dark mode handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Curated model list - final selection of 20 models
        const curatedModels = [
            'Grok-4',
            'Claude-Sonnet-4-Reasoning',
            'Gemini-2.5-Pro',
            'Perplexity-Sonar-Rsn-Pro',
            'Command-R-Plus',
            'Hermes-3-70B',
            'DeepClaude',
            'Kimi-K2-Instruct',
            'Kimi-K2-T',
            'DeepSeek-R1-FW',
            'o3-pro',
            'Mistral-Large-2',
            'Claude-Opus-4-Reasoning',
            'Solar-Pro',
            'Mixtral8x22b-Inst-FW',
            'Llama-4-Maverick-B10',
            'o1',
            'DeepSeek-V3',
            'o3',
            'GPT-4.1'
        ];

        // Global state
        let executionQueue = [];
        let currentIndex = 0;
        let isRunning = false;
        let isAutomationMode = true;
        let completedCount = 0;
        let downloadedCount = 0;
        let batchCount = 0;

        // Utility functions
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function logToDebug(message) {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            logContent.innerHTML += `[${timestamp}] ${message}<br>`;
            logContent.scrollTop = logContent.scrollHeight;
            console.log(`[DEBUG] ${message}`);
        }

        function updateProgressText() {
            const progressText = document.getElementById('progress-text');
            if (!isRunning) {
                progressText.textContent = 'Ready to start';
                return;
            }
            
            if (currentIndex < executionQueue.length) {
                const remaining = executionQueue.length - currentIndex;
                progressText.textContent = `Running model ${currentIndex + 1} of ${executionQueue.length} (${remaining} remaining) | Downloaded: ${downloadedCount}`;
            } else {
                progressText.textContent = `Completed all models | Downloaded: ${downloadedCount}`;
            }
        }

        // Model selection and queue management
        function initializeModelSelection() {
            const selectionContainer = document.getElementById('model-selection');
            
            curatedModels.forEach((model, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 border border-gray-200 dark:border-gray-600 rounded';
                div.innerHTML = `
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" class="model-checkbox mr-3" data-model="${model}">
                        <span class="text-sm">${model}</span>
                    </label>
                `;
                selectionContainer.appendChild(div);
            });

            // Add event listeners
            document.querySelectorAll('.model-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', updateQueue);
            });
        }

        function updateQueue() {
            const selectedModels = Array.from(document.querySelectorAll('.model-checkbox:checked'))
                .map(cb => cb.dataset.model);
            
            executionQueue = [...selectedModels];
            renderQueue();
            updateQueueCount();
        }

        function renderQueue() {
            const queueContainer = document.getElementById('execution-queue');
            
            if (executionQueue.length === 0) {
                queueContainer.innerHTML = '<p class="text-gray-500 italic">Select models to build queue</p>';
                return;
            }

            queueContainer.innerHTML = '';
            executionQueue.forEach((model, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item flex items-center justify-between p-2 border border-gray-200 dark:border-gray-600 rounded';
                div.dataset.index = index;
                
                let statusClass = 'pending';
                let statusText = 'Pending';
                
                if (index < currentIndex) {
                    statusClass = completedModels.has(model) ? 'completed' : 'failed';
                    statusText = completedModels.has(model) ? 'Completed' : 'Failed';
                } else if (index === currentIndex && isRunning) {
                    statusClass = 'running';
                    statusText = 'Running';
                }
                
                if (statusClass) {
                    div.classList.add(statusClass);
                }
                
                div.innerHTML = `
                    <span class="text-sm">${index + 1}. ${model}</span>
                    <div class="flex items-center gap-2">
                        <span class="text-xs px-2 py-1 rounded ${statusClass}">${statusText}</span>
                        <div class="flex flex-col">
                            <button class="move-up text-xs px-1 hover:bg-gray-200 dark:hover:bg-gray-600 rounded" data-index="${index}" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button class="move-down text-xs px-1 hover:bg-gray-200 dark:hover:bg-gray-600 rounded" data-index="${index}" ${index === executionQueue.length - 1 ? 'disabled' : ''}>↓</button>
                        </div>
                    </div>
                `;
                
                queueContainer.appendChild(div);
            });

            // Add reorder event listeners
            document.querySelectorAll('.move-up').forEach(btn => {
                btn.addEventListener('click', (e) => moveItem(parseInt(e.target.dataset.index), -1));
            });
            document.querySelectorAll('.move-down').forEach(btn => {
                btn.addEventListener('click', (e) => moveItem(parseInt(e.target.dataset.index), 1));
            });
        }

        function moveItem(index, direction) {
            if (isRunning) return; // Don't allow reordering during execution
            
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= executionQueue.length) return;
            
            // Swap items
            [executionQueue[index], executionQueue[newIndex]] = [executionQueue[newIndex], executionQueue[index]];
            renderQueue();
        }

        function updateQueueCount() {
            document.getElementById('queue-count').textContent = executionQueue.length;
        }

        // Execution engine
        let completedModels = new Set();

        async function startExecution(automationMode = true) {
            if (executionQueue.length === 0) {
                showNotification('Please select at least one model');
                return;
            }

            const mainPrompt = document.getElementById('main-prompt').value.trim();
            if (!mainPrompt) {
                showNotification('Please enter a main prompt');
                return;
            }

            isRunning = true;
            isAutomationMode = automationMode;
            currentIndex = 0;
            completedCount = 0;
            downloadedCount = 0;
            batchCount = 0;
            completedModels.clear();

            // Update UI
            document.getElementById('start-automation').disabled = true;
            document.getElementById('start-manual').disabled = true;
            document.getElementById('stop-execution').classList.remove('hidden');
            
            updateProgressText();
            renderQueue();

            logToDebug(`Started ${automationMode ? 'automation' : 'manual'} mode with ${executionQueue.length} models`);

            if (automationMode) {
                await runAutomationMode();
            } else {
                await runManualMode();
            }
        }

        async function runAutomationMode() {
            while (currentIndex < executionQueue.length && isRunning) {
                const batchStart = currentIndex;
                const batchEnd = Math.min(currentIndex + 5, executionQueue.length);
                
                logToDebug(`Starting batch ${batchCount + 1}: models ${batchStart + 1}-${batchEnd}`);

                // Run batch of 5
                for (let i = batchStart; i < batchEnd && isRunning; i++) {
                    await executeModel(i);
                    if (isRunning) currentIndex++;
                }

                batchCount++;

                // Check if we should show checkpoint
                if (isRunning && currentIndex < executionQueue.length) {
                    const shouldContinue = await showCheckpoint();
                    if (!shouldContinue) {
                        break;
                    }
                }
            }

            if (isRunning) {
                completeExecution();
            }
        }

        async function runManualMode() {
            if (currentIndex < executionQueue.length) {
                await executeModel(currentIndex);
                if (isRunning) {
                    currentIndex++;
                    updateProgressText();
                    renderQueue();

                    // Auto-continue to next model after brief delay
                    if (currentIndex < executionQueue.length) {
                        setTimeout(() => {
                            if (isRunning) runManualMode();
                        }, 1000);
                    } else {
                        completeExecution();
                    }
                }
            }
        }

        async function executeModel(index) {
            if (!isRunning || index >= executionQueue.length) return;

            const model = executionQueue[index];
            logToDebug(`Executing model ${index + 1}: ${model}`);

            updateProgressText();
            renderQueue();

            // Update current model info
            document.getElementById('current-model-info').innerHTML = `
                <div class="loading-spinner"></div>
                <span class="ml-2">Running: ${model}</span>
            `;

            // Show loading in response area
            const responseArea = document.getElementById('response-area');
            responseArea.classList.add('active');
            responseArea.innerHTML = `
                <div class="flex items-center justify-center">
                    <div class="loading-spinner"></div>
                    <span class="ml-3">Generating response for ${model}...</span>
                </div>
            `;

            try {
                await generateResponse(model, index);
            } catch (error) {
                logToDebug(`Error executing ${model}: ${error.message}`);
                handleModelFailure(model, index);
            }
        }

        async function generateResponse(model, index) {
            return new Promise(async (resolve) => {
                // Check if Poe API is available
                if (!window.Poe) {
                    logToDebug(`ERROR: Poe API not available for ${model}`);
                    handleModelFailure(model, index);
                    resolve();
                    return;
                }

                const mainPrompt = document.getElementById('main-prompt').value;
                const systemPrompt = document.getElementById('system-prompt').value;

                // Construct prompt
                let fullPrompt = `@${model} `;
                if (systemPrompt) {
                    fullPrompt += `${systemPrompt}\n\n`;
                }
                fullPrompt += mainPrompt;

                logToDebug(`Sending prompt to ${model}: ${fullPrompt.substring(0, 100)}...`);

                const handlerName = 'exec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const responseArea = document.getElementById('response-area');

                try {
                    window.Poe.registerHandler(handlerName, async (result) => {
                        logToDebug(`Handler ${handlerName} received result for ${model}: status=${result.status}`);
                        
                        if (!result.responses || result.responses.length === 0) {
                            logToDebug(`No responses received for ${model}`);
                            handleModelFailure(model, index);
                            resolve();
                            return;
                        }

                        const msg = result.responses[0];
                        logToDebug(`Message status: ${msg.status}, content length: ${msg.content?.length || 0}`);

                        if (msg.status === 'error') {
                            logToDebug(`Model ${model} returned error: ${msg.statusText || msg.content}`);
                            handleModelFailure(model, index);
                            resolve();
                        } else if (msg.status === 'incomplete') {
                            // Update UI with partial response
                            try {
                                responseArea.innerHTML = marked.parse(msg.content || '');
                            } catch (e) {
                                responseArea.innerHTML = msg.content || '';
                            }
                        } else if (msg.status === 'complete') {
                            logToDebug(`Model ${model} completed successfully`);
                            
                            // Update UI with final response
                            try {
                                responseArea.innerHTML = marked.parse(msg.content || '');
                            } catch (e) {
                                responseArea.innerHTML = msg.content || '';
                            }

                            // Mark as completed and trigger download
                            completedModels.add(model);
                            completedCount++;
                            responseArea.classList.remove('active');

                            // Auto-download with delay
                            setTimeout(() => {
                                downloadResponse(model, msg.content || '');
                                downloadedCount++;
                                updateProgressText();
                            }, 5000); // 5 second delay

                            // Update current model info
                            document.getElementById('current-model-info').innerHTML = `
                                <span class="text-green-600">✓ Completed: ${model}</span>
                            `;

                            resolve();
                        }
                    });

                    // Set timeout for stuck responses
                    const timeoutId = setTimeout(() => {
                        logToDebug(`Timeout for ${model} - no response after 3 minutes`);
                        handleModelFailure(model, index);
                        resolve();
                    }, 180000); // 3 minutes

                    // Send message
                    logToDebug(`Calling sendUserMessage for ${model}...`);
                    const result = await window.Poe.sendUserMessage(fullPrompt, {
                        handler: handlerName,
                        stream: true,
                        openChat: false
                    });
                    
                    logToDebug(`sendUserMessage result for ${model}: ${JSON.stringify(result)}`);

                } catch (error) {
                    logToDebug(`Exception in generateResponse for ${model}: ${error.message}`);
                    logToDebug(`Error stack: ${error.stack}`);
                    handleModelFailure(model, index);
                    resolve();
                }
            });
        }

        function handleModelFailure(model, index) {
            logToDebug(`Handling failure for ${model} at index ${index}`);
            
            const responseArea = document.getElementById('response-area');
            responseArea.classList.remove('active');
            responseArea.innerHTML = `
                <div class="text-red-500 text-center">
                    <strong>Error:</strong> Failed to get response from ${model}<br>
                    <small>Skipping and continuing to next model...</small>
                </div>
            `;

            document.getElementById('current-model-info').innerHTML = `
                <span class="text-red-600">✗ Failed: ${model}</span>
            `;

            // Don't increment completedCount for failed models
            renderQueue();
        }

        function downloadResponse(modelName, content) {
            try {
                const now = new Date();
                const timeString = now.getHours().toString().padStart(2, '0') + 
                                  now.getMinutes().toString().padStart(2, '0');
                const filename = `${modelName}_${timeString}.md`;
                
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                logToDebug(`Downloaded: ${filename}`);
                showNotification(`Downloaded: ${filename}`);
            } catch (error) {
                logToDebug(`Download failed for ${modelName}: ${error.message}`);
                // Continue execution even if download fails
            }
        }

        async function showCheckpoint() {
            return new Promise((resolve) => {
                document.getElementById('checkpoint-completed').textContent = completedCount;
                document.getElementById('checkpoint-downloads').textContent = downloadedCount;
                document.getElementById('checkpoint-modal').classList.remove('hidden');

                const continueBtn = document.getElementById('checkpoint-continue');
                const stopBtn = document.getElementById('checkpoint-stop');

                const handleContinue = () => {
                    document.getElementById('checkpoint-modal').classList.add('hidden');
                    continueBtn.removeEventListener('click', handleContinue);
                    stopBtn.removeEventListener('click', handleStop);
                    resolve(true);
                };

                const handleStop = () => {
                    document.getElementById('checkpoint-modal').classList.add('hidden');
                    continueBtn.removeEventListener('click', handleContinue);
                    stopBtn.removeEventListener('click', handleStop);
                    resolve(false);
                };

                continueBtn.addEventListener('click', handleContinue);
                stopBtn.addEventListener('click', handleStop);
            });
        }

        function stopExecution() {
            isRunning = false;
            logToDebug('Execution stopped by user');
            completeExecution();
        }

        function completeExecution() {
            isRunning = false;

            // Update UI
            document.getElementById('start-automation').disabled = false;
            document.getElementById('start-manual').disabled = false;
            document.getElementById('stop-execution').classList.add('hidden');
            
            updateProgressText();
            renderQueue();

            const responseArea = document.getElementById('response-area');
            responseArea.classList.remove('active');
            
            document.getElementById('current-model-info').innerHTML = `
                <span class="text-blue-600">Execution completed | Models: ${completedCount}/${executionQueue.length} | Downloads: ${downloadedCount}</span>
            `;

            logToDebug(`Execution completed. ${completedCount}/${executionQueue.length} models successful, ${downloadedCount} downloads`);
            showNotification(`Execution completed! ${completedCount} models successful, ${downloadedCount} downloads`);
        }

        // Event listeners
        document.getElementById('select-all').addEventListener('click', () => {
            document.querySelectorAll('.model-checkbox').forEach(cb => cb.checked = true);
            updateQueue();
        });

        document.getElementById('clear-all').addEventListener('click', () => {
            document.querySelectorAll('.model-checkbox').forEach(cb => cb.checked = false);
            updateQueue();
        });

        document.getElementById('start-automation').addEventListener('click', () => startExecution(true));
        document.getElementById('start-manual').addEventListener('click', () => startExecution(false));
        document.getElementById('stop-execution').addEventListener('click', stopExecution);

        document.getElementById('toggle-log').addEventListener('click', () => {
            const debugLog = document.getElementById('debug-log');
            const toggleBtn = document.getElementById('toggle-log');
            
            if (debugLog.classList.contains('hidden')) {
                debugLog.classList.remove('hidden');
                toggleBtn.textContent = 'Hide Debug Log';
            } else {
                debugLog.classList.add('hidden');
                toggleBtn.textContent = 'Show Debug Log';
            }
        });

        // Initialize and debug
        logToDebug('Starting initialization...');
        logToDebug(`Window.Poe available: ${!!window.Poe}`);
        if (window.Poe) {
            logToDebug(`Poe methods: ${Object.keys(window.Poe).join(', ')}`);
        }
        
        initializeModelSelection();
        logToDebug(`Model selection initialized with ${curatedModels.length} models`);
        logToDebug('AI Model Automation Runner fully initialized');
        
        // Test basic functionality
        document.addEventListener('DOMContentLoaded', () => {
            logToDebug('DOM fully loaded');
        });
    </script>
</body>
</html>
